<!doctype html>
<body>
  <canvas id="keys" width="100%" height="100%"> </canvas>
  <script>
    window.addEventListener("message", updateImages);

    // Disabling the scroll bar
    document.documentElement.style.overflow = "hidden";

    sizeXOffset = {
      small: 0,
      medium: 0,
      large: 6,
    };

    sizeYOffset = {
      small: 20,
      medium: 8,
      large: 8,
    };

    sizeTopMargin = {
      small: "8px",
      medium: "14px",
      large: "14px",
    };

    const IMAGE_SCALE = 0.9;
    const OUTLINE_SCALE = 0.65;

    function updateImages(message) {
      const messageString = new TextDecoder().decode(message.data.content);
      const data = JSON.parse(messageString);
      console.log(data.heldkeys);

      const canvas = document.getElementById("keys");
      document.body.style.marginTop = sizeTopMargin[data.floorsize];
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      const ctx = canvas.getContext("2d");

      for (let x = 0; x < data.rooms.length; x++) {
        for (let y = 0; y < data.rooms[x].length; y++) {
          console.log(data.rooms[x][y]);
          if (
            data.rooms[x][y].hasOwnProperty("key") &&
            !data.rooms[x][y].roomshape.startsWith("o_")
          ) {
            const image = new Image();
            image.onload = function (event) {
              // Getting the x, y position of the room in the canvas
              const roomX = x * 32 + sizeXOffset[data.floorsize];
              const roomY =
                canvas.height -
                (y + 2) * 32 +
                sizeYOffset[data.floorsize] +
                y * 0.5;

              // Attempting to center the image on the room
              const keyX = roomX + (14 - (this.width * IMAGE_SCALE) / 2);
              const keyY = roomY + (14 - (this.height * IMAGE_SCALE) / 2);

              // If the player currently holds this key, draw a yellow outline
              if (data.heldkeys.includes(data.rooms[x][y].key)) {
                for (var sx = -2; sx <= 2; sx++) {
                  for (var sy = -2; sy <= 2; sy++) {
                    ctx.shadowColor = "yellow";
                    ctx.shadowBlur = 0;
                    ctx.shadowOffsetX = sx * OUTLINE_SCALE;
                    ctx.shadowOffsetY = sy * OUTLINE_SCALE;
                    ctx.drawImage(
                      image,
                      keyX,
                      keyY,
                      this.width * IMAGE_SCALE,
                      this.height * IMAGE_SCALE,
                    );
                  }
                }
              }
              // Draw without outline
              else {
                ctx.drawImage(
                  image,
                  keyX,
                  keyY,
                  this.width * IMAGE_SCALE,
                  this.height * IMAGE_SCALE,
                );
              }
              ctx.shadowOffsetX = 0;
              ctx.shadowOffsetY = 0;
            };
            image.src = "./images/keys/" + data.rooms[x][y].key + ".png";
          } else if (data.rooms[x][y].hasOwnProperty("gatestone")) {
            const image = new Image();

            image.onload = function (event) {
              const roomX = x * 32 + sizeXOffset[data.floorsize];
              const roomY =
                canvas.height - (y + 2) * 32 + sizeYOffset[data.floorsize];

              const keyX = roomX + (14 - (this.width * IMAGE_SCALE) / 2);
              const keyY = roomY + (14 - (this.height * IMAGE_SCALE) / 2);
              console.log(keyX, keyY);

              ctx.drawImage(
                image,
                keyX,
                keyY,
                this.width * IMAGE_SCALE,
                this.height * IMAGE_SCALE,
              );
            };
            image.src =
              "./images/gatestones/" + data.rooms[x][y].gatestone + ".png";
          }
        }
      }
      console.log();
    }
  </script>
</body>
